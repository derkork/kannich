#!/bin/bash
# Kannich Wrapper Script
# Runs Kannich inside Docker - no local JVM required.
# Commit this file with your project to enable portable CI builds.

set -e

# Configuration
KANNICH_VERSION="${KANNICH_VERSION:-latest}"
KANNICH_IMAGE="derkork/kannich:${KANNICH_VERSION}"
KANNICH_CACHE_DIR="${KANNICH_CACHE_DIR:-$HOME/.kannich/cache}"

# Default prefixes for environment variables to pass to Docker
DEFAULT_ENV_PREFIXES="CI_ GITHUB_ BUILD_ CIRCLE_ TRAVIS_ BITBUCKET_ KANNICH_"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Determine project directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="${PROJECT_DIR:-$SCRIPT_DIR}"

# Check for Docker
if ! command -v docker &> /dev/null; then
    echo -e "${RED}Error: Docker not found. Please install Docker.${NC}"
    exit 1
fi

if ! docker info &> /dev/null 2>&1; then
    echo -e "${RED}Error: Docker daemon not running. Please start Docker.${NC}"
    exit 1
fi

# Ensure cache directory exists on host (required for Docker mount)
if [ ! -d "$KANNICH_CACHE_DIR" ]; then
    echo "Creating cache directory: $KANNICH_CACHE_DIR"
    mkdir -p "$KANNICH_CACHE_DIR" || {
        echo -e "${RED}Error: Failed to create cache directory: $KANNICH_CACHE_DIR${NC}"
        exit 1
    }
fi

# Verify cache directory is accessible
if [ ! -d "$KANNICH_CACHE_DIR" ]; then
    echo -e "${RED}Error: Cache directory not accessible: $KANNICH_CACHE_DIR${NC}"
    exit 1
fi

# Pull image if not present
if ! docker image inspect "$KANNICH_IMAGE" &> /dev/null; then
    echo -e "${YELLOW}Pulling Kannich builder image...${NC}"
    docker pull "$KANNICH_IMAGE"
fi

# Convert paths to Docker-compatible format if running on Windows (MSYS/Git Bash)
PROJECT_DOCKER_PATH="$PROJECT_DIR"
CACHE_DOCKER_PATH="$KANNICH_CACHE_DIR"

if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
    # Convert D:\foo to /d/foo
    PROJECT_DOCKER_PATH=$(echo "$PROJECT_DIR" | sed -e 's/^\([A-Za-z]\):/\/\L\1/' -e 's/\\/\//g')
    CACHE_DOCKER_PATH=$(echo "$KANNICH_CACHE_DIR" | sed -e 's/^\([A-Za-z]\):/\/\L\1/' -e 's/\\/\//g')
fi

# Container name for cleanup
CONTAINER_NAME="kannich-$$"

# Read environment variable prefixes from .kannichenv or use defaults
ENV_PREFIXES=""
if [ -f "$PROJECT_DIR/.kannichenv" ]; then
    # Read prefixes from file, ignoring comments and empty lines
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip comments and empty lines
        line=$(echo "$line" | sed 's/#.*//' | xargs)
        if [ -n "$line" ]; then
            ENV_PREFIXES="$ENV_PREFIXES $line"
        fi
    done < "$PROJECT_DIR/.kannichenv"
else
    ENV_PREFIXES="$DEFAULT_ENV_PREFIXES"
fi

# Build environment variable arguments for docker
ENV_ARGS=""
for prefix in $ENV_PREFIXES; do
    # Find all environment variables starting with this prefix
    for var in $(env | grep "^$prefix" | cut -d= -f1); do
        ENV_ARGS="$ENV_ARGS -e $var"
    done
done

# Always forward all DOCKER_* environment variables (regardless of .kannichenv)
for var in $(env | grep "^DOCKER_" | cut -d= -f1); do
    ENV_ARGS="$ENV_ARGS -e $var"
done

# Determine Docker socket mount
# If DOCKER_HOST is set and is a unix socket, use that path
# Otherwise default to /var/run/docker.sock
DOCKER_SOCKET_MOUNT=""
if [ -n "$DOCKER_HOST" ]; then
    case "$DOCKER_HOST" in
        unix://*)
            # Extract socket path from unix:///path/to/socket
            DOCKER_SOCKET_PATH="${DOCKER_HOST#unix://}"
            DOCKER_SOCKET_MOUNT="-v $DOCKER_SOCKET_PATH:$DOCKER_SOCKET_PATH"
            ;;
        tcp://*)
            # TCP connection - no socket mount needed, DOCKER_HOST env var handles it
            DOCKER_SOCKET_MOUNT=""
            ;;
        *)
            # Unknown format, try default socket
            DOCKER_SOCKET_MOUNT="-v /var/run/docker.sock:/var/run/docker.sock"
            ;;
    esac
else
    # No DOCKER_HOST set, use default socket
    DOCKER_SOCKET_MOUNT="-v /var/run/docker.sock:/var/run/docker.sock"
fi

# Cleanup function to stop the container on exit
cleanup() {
    if [ -n "$CONTAINER_NAME" ]; then
        docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
    fi
}

# Trap signals to ensure cleanup
trap cleanup EXIT INT TERM

# Run Kannich inside Docker
# --init: Use tini for proper signal handling and zombie reaping
# --name: Named container for cleanup on Ctrl+C
# Pass host paths as environment variables for nested container mounts
# shellcheck disable=SC2086
docker run --rm -it \
    --init \
    --name "$CONTAINER_NAME" \
    -v "$PROJECT_DOCKER_PATH:/workspace" \
    -v "$CACHE_DOCKER_PATH:/kannich/cache" \
    $DOCKER_SOCKET_MOUNT \
    -e "KANNICH_HOST_PROJECT_DIR=$PROJECT_DOCKER_PATH" \
    -e "KANNICH_HOST_CACHE_DIR=$CACHE_DOCKER_PATH" \
    $ENV_ARGS \
    -w /workspace \
    "$KANNICH_IMAGE" \
    /kannich/jdk/bin/java -jar /kannich/kannich-cli.jar "$@"
