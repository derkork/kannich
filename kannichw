#!/bin/sh
# Kannich Wrapper Script
# Runs Kannich inside Docker - no local JVM required.
# Commit this file with your project to enable portable CI builds.

set -e

# Configuration
KANNICH_IMAGE="${KANNICH_IMAGE:-derkork/kannich:latest}"
KANNICH_CACHE_DIR="${KANNICH_CACHE_DIR:-$HOME/.kannich/cache}"

# Default prefixes for environment variables to pass to Docker
DEFAULT_ENV_PREFIXES="CI_ GITHUB_ BUILD_ CIRCLE_ TRAVIS_ BITBUCKET_ KANNICH_"

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Determine project directory
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="${PROJECT_DIR:-$SCRIPT_DIR}"

# Detect --dev-mode / -d flag (passed through to CLI, but we need to mount volume)
DEV_MODE=0
for arg in "$@"; do
    case "$arg" in
        --dev-mode|-d)
            DEV_MODE=1
            break
            ;;
    esac
done

# Check for Docker
if ! command -v docker >/dev/null 2>&1; then
    printf "%bError: Docker not found. Please install Docker.%b\n" "$RED" "$NC"
    exit 1
fi

if ! docker info >/dev/null 2>&1; then
    printf "%bError: Docker daemon not running. Please start Docker.%b\n" "$RED" "$NC"
    exit 1
fi

# Ensure cache directory exists on host (required for Docker mount)
if [ ! -d "$KANNICH_CACHE_DIR" ]; then
    echo "Creating cache directory: $KANNICH_CACHE_DIR"
    mkdir -p "$KANNICH_CACHE_DIR" || {
        printf "%bError: Failed to create cache directory: $KANNICH_CACHE_DIR%b\n" "$RED" "$NC"
        exit 1
    }
fi

# Verify cache directory is accessible
if [ ! -d "$KANNICH_CACHE_DIR" ]; then
    printf "%bError: Cache directory not accessible: $KANNICH_CACHE_DIR%b\n" "$RED" "$NC"
    exit 1
fi

# Pull image if not present
if ! docker image inspect "$KANNICH_IMAGE" >/dev/null 2>&1; then
    printf "%bPulling Kannich builder image...%b\n" "$YELLOW" "$NC"
    docker pull "$KANNICH_IMAGE"
fi

# Host .m2 repository path for dev mode
HOST_M2_REPO="${HOME}/.m2/repository"

# Container name for cleanup
CONTAINER_NAME="kannich-$$"

# Read environment variable prefixes from .kannichenv or use defaults
ENV_PREFIXES=""
if [ -f "$PROJECT_DIR/.kannichenv" ]; then
    # Read prefixes from file, ignoring comments and empty lines
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip comments and empty lines
        line=$(echo "$line" | sed 's/#.*//' | xargs)
        if [ -n "$line" ]; then
            ENV_PREFIXES="$ENV_PREFIXES $line"
        fi
    done < "$PROJECT_DIR/.kannichenv"
else
    ENV_PREFIXES="$DEFAULT_ENV_PREFIXES"
fi

# Build environment variable arguments for docker
ENV_ARGS=""
for prefix in $ENV_PREFIXES; do
    # Find all environment variables starting with this prefix
    for var in $(env | grep "^$prefix" | cut -d= -f1); do
        ENV_ARGS="$ENV_ARGS -e $var"
    done
done

# Always forward all DOCKER_* environment variables (regardless of .kannichenv)
for var in $(env | grep "^DOCKER_" | cut -d= -f1); do
    ENV_ARGS="$ENV_ARGS -e $var"
done

# Determine Docker socket mount
# If DOCKER_HOST is set and is a unix socket, use that path
# Otherwise default to /var/run/docker.sock
DOCKER_SOCKET_MOUNT=""
if [ -n "$DOCKER_HOST" ]; then
    case "$DOCKER_HOST" in
        unix://*)
            # Extract socket path from unix:///path/to/socket
            DOCKER_SOCKET_PATH="${DOCKER_HOST#unix://}"
            DOCKER_SOCKET_MOUNT="-v $DOCKER_SOCKET_PATH:$DOCKER_SOCKET_PATH"
            ;;
        tcp://*)
            # TCP connection - no socket mount needed, DOCKER_HOST env var handles it
            DOCKER_SOCKET_MOUNT=""
            ;;
        *)
            # Unknown format, try default socket
            DOCKER_SOCKET_MOUNT="-v /var/run/docker.sock:/var/run/docker.sock"
            ;;
    esac
else
    # No DOCKER_HOST set, use default socket
    DOCKER_SOCKET_MOUNT="-v /var/run/docker.sock:/var/run/docker.sock"
fi

# Mount DOCKER_CERT_PATH if set (for TLS certificate resolution)
DOCKER_CERT_MOUNT=""
if [ -n "$DOCKER_CERT_PATH" ]; then
    DOCKER_CERT_MOUNT="-v $DOCKER_CERT_PATH:$DOCKER_CERT_PATH"
fi

# If DOCKER_HOST is tcp://, resolve hostname to IP for container use
# This avoids DNS resolution issues inside the container
DOCKER_HOST_ENV=""
if [ -n "$DOCKER_HOST" ]; then
    case "$DOCKER_HOST" in
        tcp://*)
            # Extract host:port from tcp://host:port
            TCP_HOST_PORT="${DOCKER_HOST#tcp://}"
            TCP_HOST="${TCP_HOST_PORT%%:*}"
            TCP_PORT="${TCP_HOST_PORT##*:}"

            # Resolve hostname to IP using getent (Linux) or ping fallback
            RESOLVED_IP=""
            if command -v getent >/dev/null 2>&1; then
                RESOLVED_IP=$(getent hosts "$TCP_HOST" 2>/dev/null | awk '{print $1; exit}')
            fi

            # Fallback to ping if getent didn't work or isn't available
            if [ -z "$RESOLVED_IP" ]; then
                # ping output: "PING hostname (1.2.3.4)" - extract IP from parentheses
                RESOLVED_IP=$(ping -c 1 "$TCP_HOST" 2>/dev/null | grep -oE '\([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\)' | head -1 | tr -d '()')
            fi

            if [ -n "$RESOLVED_IP" ]; then
                DOCKER_HOST_ENV="-e DOCKER_HOST=tcp://$RESOLVED_IP:$TCP_PORT"
            fi
            ;;
    esac
fi

# Cleanup function to stop the container on exit
cleanup() {
    if [ -n "$CONTAINER_NAME" ]; then
        docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
    fi
}

# Trap signals to ensure cleanup
trap cleanup EXIT INT TERM

# Dev mode: mount host .m2/repository
DEV_MODE_MOUNT=""
if [ "$DEV_MODE" -eq 1 ]; then
    if [ ! -d "$HOST_M2_REPO" ]; then
        printf "%bError: Dev mode requires ~/.m2/repository to exist.%b\n" "$RED" "$NC"
        echo "Run 'mkdir -p ~/.m2/repository' or 'mvn install' on a project first."
        exit 1
    fi
    DEV_MODE_MOUNT="-v $HOST_M2_REPO:/kannich/dev-repo"
fi

# Run Kannich inside Docker
# --init: Use tini for proper signal handling and zombie reaping
# --name: Named container for cleanup on Ctrl+C
# shellcheck disable=SC2086
docker run --rm \
    --init \
    --name "$CONTAINER_NAME" \
    --privileged \
    -v "$PROJECT_DIR:/workspace" \
    -v "$KANNICH_CACHE_DIR:/kannich/cache" \
    $DOCKER_SOCKET_MOUNT \
    $DOCKER_CERT_MOUNT \
    $DEV_MODE_MOUNT \
    $ENV_ARGS \
    $DOCKER_HOST_ENV \
    -w /workspace \
    "$KANNICH_IMAGE" \
    /kannich/jdk/bin/java -jar /kannich/kannich-cli.jar "$@"
